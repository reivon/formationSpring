<!doctype html>
<html lang="fr">
<head>
    <meta charset="utf-8">

    <title>Comprendre Spring</title>

    <meta name="description" content="Formation générale sur le framework Spring">
    <meta name="author" content="Tony MEMBOT">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="reveal-3.3.0/css/reveal.css">
    <link rel="stylesheet" href="reveal-3.3.0/css/theme/sky.css" id="theme">
    <link rel="stylesheet" href="reveal-3.3.0/lib/css/zenburn.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? 'reveal-3.3.0/css/print/pdf.css' : 'reveal-3.3.0/css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>

    <!--[if lt IE 9]>
    <script src="reveal-3.3.0/lib/js/html5shiv.js"></script>
    <![endif]-->
</head>
<body>
<div class="reveal">
    <div class="slides">

        <!-- *************************************************************** -->
        <!-- 0. Titre & plan -->
        <!-- *************************************************************** -->

        <section>
            <h1>Comprendre Spring</h1>
            <h3>Formation au Framework multi fonction</h3>
            <p>
                <small>Créé par Tony MEMBOT via l'API de présentation <a href="https://github.com/hakimel/reveal.js">Reveal.js</a>
                </small>
            </p>

            <aside class="notes">
                Se présenter.<br/>
                Leur domaine / niveau struts/spring/MVC/...<br/>
                Pas formation expert. Il faut fouiller/adapter.<br/>
            </aside>
        </section>

        <section>
            <h2>Comprendre Spring</h2>
            <ul>
                <li>C'est quoi spring ?</li>
                <li>Spring Core</li>
                <li>Spring MVC</li>
                <li>Spring Security</li>
                <li>Spring Batch</li>
                <li>Spring et ...
                    <ul>
                        <li>les tests unitaires</li>
                        <li>AOP</li>
                        <li>Spring boot</li>
                        <li>...</li>
                    </ul>
                </li>
            </ul>

            <aside class="notes">
            </aside>
        </section>

        <!-- *************************************************************** -->
        <!-- 1. C'est quoi Spring -->
        <!-- *************************************************************** -->

        <section>

            <section>
                <h2>C'est quoi Spring ?</h2>

                <aside class="notes">
                </aside>
            </section>

            <section>
                <h3>Un conteneur léger</h3>
                <br/>
                <ul>
                    <li>Framework reposant sur 3 grands principes
                        <ul>
                            <li class="fragment">Inversion de contrôle</li>
                            <li class="fragment">Programmation orientée aspect</li>
                            <li class="fragment">Couche d'abstraction (pour d'autres API)</li>
                        </ul>
                    </li>
                    <li class="fragment"><b>2003</b> : première version.</li>
                    <li class="fragment"><b>2016</b> : 4.2.3</li>
                    <li class="fragment"><b>Libre</b></li>
                </ul>

                <aside class="notes">
                    Inversion de contrôle = Injection de dépendance. (exemple par la suite)<br/>
                    Définir programmation orienté aspect => transversale.<br/>
                    Couche d'abstraction : Hibernate / quartz / velocity / jdbc / ...<br/>
                    <br/>
                    Entre chaque version il y a eu de nombreuses et importantes évolution.<br/>
                </aside>
            </section>

            <section>
                <img src="img/spring-overview.png" style="border:0">
            </section>

            <section>
                <h2>Attention aux versions !</h2>
                <h3>Une version majeure = grand ménage de printemps</h3>
                <ul>La formation se base sur les version suivantes :
                    <li>Spring Framework : 4.3.2.RELEASE</li>
                    <li>Spring Security : 4.1.3.RELEASE</li>
                </ul>

                <aside class="notes">
                    Certains parlent de massacre à la tronçonneuse mais évoluer est nécessaire.
                </aside>
            </section>

        </section>

        <!-- *************************************************************** -->
        <!-- 2.1 Spring core -->
        <!-- *************************************************************** -->

        <section>

            <section>
                <h2>Spring core</h2>
            </section>

            <section>
                <h3>C'est quoi l'Inversion of Control</h3>
                <br/>
                <ul>
                    <li>Aujourd'hui renommé injection de dépendance</li>
                    <li>Déresponsabilisation / Déspécialisation des classes</li>
                    <li>On injecte dynamiquement les dépendances plutôt que de les écrire explicitement dans le code</li>
                </ul>

                <aside class="notes">
                </aside>
            </section>

            <section>
                <pre><code data-trim>
public class Parking {
    private Voiture voiture;

    /** Constructeur qui crée une voiture spécifique: pas d'IoC */
    public Parking() {
        voiture = new Clio();
    }

    /** Constructeur avec voiture: compatible IoC */
    public Parking(Voiture voiture) {
        this.voiture = voiture;
    }
}
                </code></pre>
                <aside class="notes">
                    Parking a ici la responsabilité de l'instanciation de la Clio. Ca ne peut être que ça.<br/>
                    Si l'application évolue, ou on souhaite l'étendre, ou on souhaite mocker pour test => on doit modifier le
                    code.
                </aside>
            </section>

            <section>
                <h3>Exemple XML</h3>
                <br/>
                <ul>
                    <li>Dépendances maven sur spring-context</li>
                    <li>Un fichier xml de configuration principal</li>
                    <li>Déclaration de bean et d'injection de dépendance via l'xml</li>
                    <li>Chargement du context spring dans le main</li>
                </ul>

                <aside class="notes">
                    Projet exemple : <b>springFormation_1</b>.<br/>
                    Dépendance de context : https://mvnrepository.com/artifact/org.springframework/spring-context/4.3.2.RELEASE
                    app / beans / core / expression.<br/>
                    Il est possible de découper le fichier XML en réalisant des imports (Mais un seul point d'entrée).
                </aside>
            </section>

            <section>
                <h3>Exemple Annotation</h3>
                <br/>
                <ul>
                    <li>Dépendances identiques</li>
                    <li>Une classe de configuration principale</li>
                    <li>Déclaration des beans et injection de dépendance via les annotations</li>
                    <li>Chargement du context spring dans le main légèrement différent</li>
                </ul>

                <aside class="notes">
                    Projet exemple : <b>springFormation_2</b>.<br/>
                    On peut retrouver l'annotation @Bean aussi<br/>
                    Ainsi, si dans messageServiceImpl on supprime le @Component, on peut déclarer dans la classe Application:<br/>
                    <pre>
                    @Bean
                    public MessageServiceImpl messageService(){
                        return new MessageServiceImpl();
                    }
                    </pre>
                    Il est à noter que l'on peut avoir plusieurs @Configuration si on souhaite découper notre application.<br/>
                    On peut réaliser des héritages / dépendances avec @Import(nomClass.class)<br/>
                </aside>
            </section>

            <section>
                <h3>Annotation ou XML ?</h3>
                <ul>
                    <li>Pas de best solution</li>
                    <li>On peut quasi tout faire dans les deux solutions</li>
                    <li>Utiliser le meilleur des deux : un mix, exemple
                        <ul>
                            <li>Annotation pour tout ce qui est <b>static</b></li>
                            <li>XML pour tout ce qui est plus <b>dynamique</b></li>
                        </ul>
                    </li>
                    <li>Mais attention, la communauté tend vers le full annotation</li>
                </ul>

                <aside class="notes">
                </aside>
            </section>

        </section>

        <!-- *************************************************************** -->
        <!-- 2.2 Déclaration d'un bean -->
        <!-- *************************************************************** -->

        <section>

            <section>
                <h3>@Component</h3>
                <ul>
                    <li>Sur la classe VoitureDeCourse va créé un bean nommé "voitureDeCourse"</li>
                    <li>On peut préciser ce nom <code data-trim>@Component(value = "voiture2course")</code></li>
                    <li>@Service, @Controller, @Repository sont des spécialisations</li>
                    <li>On laisse spring géré l'instanciation</li>
                </ul>

                <aside class="notes">
                    @Service, ... sont des spécialisations dans le but d'utiliser l'AOP.
                </aside>
            </section>

            <section>
                <h3>@Bean</h3>
                <ul>
                    <li>Disponible uniquement si on utilise @Configuration</li>
                    <li>Sur la méthode myVoitureDeCourse va créé un bean nommé "myVoitureDeCourse"</li>
                    <li>On peut préciser ce nom <code data-trim>@Bean(name={"voiture2course"})</code></li>
                    <li>C'est le développeur qui gère l'instanciation</li>
                </ul>

                <aside class="notes">
                    Attention, on ne peut plus utiliser l'AOP sur des instanciations de type @Bean.
                    => http://zezutom.blogspot.fr/2014/02/spring-series-part-5-component-vs-bean.html
                    @Autowired peut injecter un @Bean
                </aside>
            </section>

            <section>
                <h3>@Bean factory</h3>
                <pre><code data-trim>
@Bean
@Scope("prototype")
public SomeService someService() {
    switch (state) {
        case 1:
            return new Impl1();
        case 2:
            return new Impl2();
        case 3:
            return new Impl3();
        default:
            return new Impl();
    }
}
                </code></pre>

                <aside class="notes">
                    Ce cas peut être utile pour du mock par exemple, ou pour instancier des classes différentes selon un
                    environnement ...<br/>
                    La différence entre les deux est ténu. On préfera garder @Component généralement.
                </aside>
            </section>

        </section>

        <!-- *************************************************************** -->
        <!-- 2.3 Injection de dépendance -->
        <!-- *************************************************************** -->

        <section>

            <section>
                <h3>Spring MVC</h3>

                <aside class="notes">
                </aside>
            </section>

            <section>
                <h3>@Autowired</h3>

                <ul>
                    <li>Injection par <b>type</b></li>
                    <li>Et si on a deux implémentation de la même interface ? => Démonstration</li>
                    <li>Avec <code data-trim>@Qualifier("name")</code> : Injection par <b>nom</b></li>
                    <li>Peut préciser qu'il n'est pas obligatoire <code>@Autowired(required = false)</code></li>
                    <li>Annotations spring</li>
                </ul>

                <aside class="notes">
                    Démonstration : <br />
                    1. Créer une classe MessageServiceAutreImpl qui implémente MessageService<br />
                    2. Lancer l'appli. => plante.<br />
                </aside>
            </section>

            <section>
                <h4>@Resource</h4>

                <ul>
                    <li>Injection par <b>type</b></li>
                    <li>Même soucis sur la double implémentation que @Component</li>
                    <li>Avec <pre><code data-trim>@Resource(name = "name")</code></pre> : Injection par <b>nom</b></li>
                    <li>Annotation Java</li>
                </ul>

                <aside class="notes">
                    Démonstration : <br />
                    1. Créer une classe MessageServiceAutreImpl qui implémente MessageService<br />
                    2. Lancer l'appli. => plante.<br />
                </aside>
            </section>

            <section>
                <pre><code data-trim>
@Resource(name = "toto")
private Toto toto;
                </code></pre>
                <p>==</p>
                <pre><code data-trim>
@Autowired
@Qualifier("toto")
private Toto toto;
                </code></pre>

                <aside class="notes">
                </aside>
            </section>

            <section>
                <h4>@Resource ou @Autowired ?</h4>
                <p>Sur des injections de propriétés, il est préférable d'utiliser @Resource qui est un standard Java et qui est fait pour ça.</p>
                <h4>Setter ou constructeur ?</h4>
                <p>On peut mixer les deux. La logique veut qu'on mette en setter les dépendances facultatives et en constructeurs les obligatoires.</p>

                <aside class="notes">
                </aside>
            </section>

            <section>
                <h4>Le scope d'injection</h4>
                <ul>
                    <li class="fragment">Modifions un peu le projet Spring2 ...</li>
                    <li class="fragment">Par défaut tout est singleton !</li>
                    <li class="fragment">
                        <ul>
                            <li>Singleton</li>
                            <li>Prototype</li>
                            <li>Request *</li>
                            <li>Session *</li>
                            <li>GlobalSession *</li>
                        </ul>
                    </li>
                </ul>

                <aside class="notes">
                    Faire un test sur formationSpring_2 en ajoutant un 2ème service dans MessagePrinter.
                    Puis ajouter dans l'appel d'affichage
                    System.out.println(service2.getMessage());
                    service2.setMessage("message modifié");
                    System.out.println(service.getMessage());
                    System.out.println(service2.getMessage());

                    * = que dans spring web.
                    Ajouter => @Scope("prototype")
                </aside>
            </section>

            <section>
                <h4>Injection de collections</h4>
                <ul class="fragment">
                    <li>list</li>
                    <li>set</li>
                    <li>map</li>
                    <li>props</li>
                </ul>
                <ul>
                    <li class="fragment"></li>
                    <li class="fragment">Tout est string dans un fichier xml ...</li>
                    <li class="fragment">... mais il existe des converter automatique</li>
                    <li class="fragment">Et l'injection d'une valeur null ?</li>
                    <li class="fragment"><pre><code data-trim><value><null/></value></code></pre></li>
                </ul>

                <aside class="notes">
                    Exemple avec le projet spring 3.
                    L'utilité de tout ça ? notamment pour injecter des listes de beans / référence.
                    Injecter null ? "" représentant une chaîne vide ?
                </aside>
            </section>
        </section>

        <!-- *************************************************************** -->
        <!-- 2.4 Plus loin dans la configuration des beans -->
        <!-- *************************************************************** -->

        <section>
            <section>
                <h2>Customiser ses beans</h2>
            </section>

            <section>
                <h3>init-method</h3>
                <pre><code data-trim><bean id="..." class="..." init-method="..."></code></pre>

                <aside class="notes">
                    Modifier le projet 1 pour ajouter une init method à messageserviceimpl qui changerait le message par exemple.
                </aside>
            </section>

            <section>
                <h3>L'héritage / Surcharge des beans</h3>
<pre><code data-trim>
<bean id="helloworld" class="fr.tuto.helloworld">
    <property name="message1" value="hello world!"></property>
    <property name="message2" value="hello second world!"></property>
</bean>

<bean id="helloindia" class="fr.tuto.helloindia" parent="helloworld">
   <property name="message1" value="hello india!"></property>
   <property name="message3" value="namaste india!"></property>
</bean>
</code></pre>

                <aside class="notes">
                    On peut rendre un bean abstract="true" sans définir de class (sera pas instancié par Spring)
                    http://www.tutorialspoint.com/spring/spring_bean_definition_inheritance.htm
                </aside>
            </section>
        </section>

        <section>
            <h3>Testons !</h3>
            <ol style="font-size:90%;">
                <li>Instancier via un new (projet 1)</li>
                <li>Complétons le projet Exo 1 ...
                    <ul>
                        <li>Créer les beans des voitures clio / ferrari / lotus</li>
                        <li>Créer deux parking
                            <ul>
                                <li>Concession : avec deux clio, une ferrari, deux lotus</li>
                                <li>Occasion : avec deux clio, une lotus</li>
                            </ul>
                        </li>
                        <li>Les parking initialisent les niveaux d'essences via initEssence()</li>
                        <li>Créer le bean garage référençant les deux parking et le commercial</li>
                        <li>GarageApplication doit tourner !</li>
                    </ul>
                </li>
            </ol>

            <aside class="notes">
                1. L'objet est hors contexte, pas d'initialisation de variable etc. erreur courante au début !<br/>
                2. voiture ne doit pas être instancié, les voitures = prototype<br />
                Montrer exemple spEL
            </aside>
        </section>

        <!-- *************************************************************** -->
        <!-- 2.5 Spring properties -->
        <!-- *************************************************************** -->

        <section>
            <section>
                <h3>Spring properties</h3>

                <ul>
                    <li>Externaliser les données "changeantes" / technique</li>
                    <li>Chargement de properties dans le context spring</li>
                    <li>Récupération des valeurs directement dans l'initialisation d'un bean ou via un @value</li>
                    <li>Possibilité de mettre en place un système de surcharge</li>
                    <li>Possibilité de mettre des valeurs par défaut</li>
                </ul>

                <aside class="notes">
                    exemple du projet 4.
                    pour utiliser la variable, déclarer dans les arguments vm : -Dproject.home=c:/
                    rajouter une valeur par défaut : :c:/conf/
                </aside>
            </section>
        </section>

        <!-- *************************************************************** -->
        <!-- 3. Spring MVC -->
        <!-- *************************************************************** -->

        <section>
            <section>
                <h2>Spring Web (MVC)</h2>
            </section>

            <section>
                <h3>MVC : un petit rappel</h3>
                <img src="img/MVC_2.png"/>

                <aside class="notes">
                    découpage de responsabilité ...
                </aside>
            </section>

            <section>
                <h3>Spring & le web</h3>
                <img src="img/mvc.png"/>

                <aside class="notes">
                    spring mvc est une spécialisation de spring qui donne des outils pour gérer des pages web.
                </aside>
            </section>
        </section>

        <!-- *************************************************************** -->
        <!-- 3.1 Dispatcher -->
        <!-- *************************************************************** -->

        <section>
            <section>
                <h2>Le dispatcher</h2>
            </section>

            <section>
                <h3>Le dispatcher</h3>
                <ul>
                    <li>Spring web tourne autour du servletdispatcher (remplace notre main)</li>
                    <li>Chef d'orchestre des appels HTTP et de leurs traitements</li>
                </ul>

                <aside class="notes">
                </aside>
            </section>

            <section>
                <h3>Request HTTP basique</h3>
                <img src="img/spring_dispatcherservlet.png">

                <ol>
                    <li>Récupération du bon controller</li>
                    <li>Aiguillage (POST/GET) & préparatop, les datas</li>
                    <li>Récupération de la bonne view (JSP, ...)</li>
                    <li>Fusion des datas dans la view</li>
                </ol>

                <aside class="notes">
                    1. Après l'avoir reçu, DispatcherServlet consulte HandlerMapping pour appelerle bon Controller.<br/>
                    2. Le Controller gère la request et appel la bonne méthode (GET / POST) et prépare les objets qui vont alimentés le model ainsi que le nom du modèle.<br/>
                    3. Le DispatcherServlet utilise le ViewResolver pour récupérer la bonne view.<br/>
                    4. Le DispatcherServlet fusione les datas avec la view et retourne le résultat.<br/>
                </aside>
            </section>
            
            <section>
                <h3>Explorons le projet spring 5 ...</h3>

                <aside class="notes">
                    lancer l'appli et accéder à http://localhost:8080/hello (si lancer depuis intellij)<br/>
                    web.xml => dispatcher servlet<br/>
                    hellocontroller => @controller @requestmapping<br/>
                    hello-servlet<br/>
                    => spring recherche automatiquement le fichier {{nomservlet}}-servlet.xml<br/>
                    => on peut lui préciser d'autres noms dans le web.xml<br/>
                    => contient la ligne de scan pour les controller<br/>
                    => contient un résolver permettant de rediriger vers nos ressources jsp.<br/>
                    => le resolver peut implémenter des framework de view comme tiles / velocity / ...v
                </aside>
            </section>
        </section>

        <!-- *************************************************************** -->
        <!-- 3.2 Spring EL -->
        <!-- *************************************************************** -->

        <section>

            <section>
                <h3>Spring EL</h3>

                <ul>
                    <li>EL = Expression Language</li>
                    <li>Spring EL = EL au niveau injection / context spring</li>
                    <li>Explorons le projet spring 6 ...</li>
                </ul>

                <aside class="notes">
                    localhost:8080/hello & localhost:8080/hello/toto<br/>
                    spring-el est déjà en dépendance de webmvc<br/>
                    dépendance : ne pas oublier d'ajouter javax.servlet<br/>
                    <br/>

                    attention à la vieille erreur que les paramètres ne s'affichent pas sur les jsp
                    https://www.mkyong.com/spring-mvc/modelandviews-model-value-is-not-displayed-in-jsp-via-el/
                    (web.xml) el ne marche pas :
<pre><code  data-trim>
<!doctype web-app public
"-//sun microsystems, inc.//dtd web application 2.3//en"
"http://java.sun.com/dtd/web-app_2_3.dtd" >
</code></pre>
                    (web.xml) el marche  :
<pre><code  data-trim>
<web-app id="webapp_id" version="2.4"
         xmlns="http://java.sun.com/xml/ns/j2ee"
         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"
         xsi:schemalocation="http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd">
</web-app>
</code></pre>
                </aside>
            </section>

            <section>
                <h3></h3>

                <aside class="notes">
                </aside>
            </section>
        </section>

        <!-- *************************************************************** -->
        <!-- 7. Spring plus loin -->
        <!-- *************************************************************** -->

        <section>

            <section>
                <h2>Aller plus loin dans Spring</h2>
            </section>

            <section>
                <h3>Spring 5</h3>
                <ul>
                    <li>Release prévu en Mars 2017</li>
                    <li>Niveau de compatibilité drastiquement augmenté
                        <ul>
                            <li>Java 8+</li>
                            <li>Hibernate 5+</li>
                            <li>JPA 2.1+</li>
                            <li>Inclusion de spring reactive</li>
                        </ul>
                    </li>
                </ul>

                <aside class="notes">
                    spring reactive => Programmation réactive = programmation avec des flux de données asynchrones
                    http://home.heeere.com/tech-intro-programmation-reactive.html
                </aside>
            </section>

            <section>
                <h3>Spring 5</h3>
                <li>Abandon du support de nombreuses librairies :
                    <ul>
                        <li>PortletMVC</li>
                        <li>JDO</li>
                        <li>Guava caching</li>
                        <li>JasperReports</li>
                        <li>OpenJPA</li>
                        <li>Tiles 2</li>
                        <li>XMLBeans</li>
                        <li>Velocity</li>
                    </ul>
                </li>
            </section>
        </section>

    </div> <!-- End div slide -->

</div> <!-- End div Reveal -->

<!-- Scripts insertions -->
<script src="reveal-3.3.0/lib/js/head.min.js"></script>
<script src="reveal-3.3.0/js/reveal.js"></script>

<script>
    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Optional reveal.js plugins
        dependencies: [
            {
                src: 'reveal-3.3.0/lib/js/classList.js', condition: function () {
                return !document.body.classList;
            }
            },
            {
                src: 'reveal-3.3.0/plugin/highlight/highlight.js', async: true, callback: function () {
                hljs.initHighlightingOnLoad();
            }
            },
            {src: 'reveal-3.3.0/plugin/zoom-js/zoom.js', async: true},
            {src: 'reveal-3.3.0/plugin/notes/notes.js', async: true}
        ]
    });
</script>
</body>
</html>
