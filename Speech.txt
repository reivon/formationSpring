Tuto plante : http://yannart.developpez.com/java/spring/tutoriel/
Tuto web : http://rpouiller.developpez.com/tutoriels/spring/application-web-spring-hibernate/

spring framework : http://projects.spring.io/spring-framework/
Getting started : https://docs.spring.io/spring/docs/current/spring-framework-reference/html/overview-getting-started-with-spring.html


### 0. Présentation spring framework
	Aujourd'hui version 4.2.3
	Version 5 bientôt

	Ce n'est pas une formation expert, c'est une vision de ce qui vous attend à 90%. Le reste il faut fouiller / adapter.


### 1. Spring core


 -- Pourquoi spring ?

/**
 * Pot qui contient une plante.
 */
public class Pot {
	/** Plante dans le pot */
	private Plante plante;
	/** Constructeur qui crée une plante spécifique: pas d'IoC*/
	public Pot() {
		plante = new Tomate();
	}
	/** Constructeur avec plante: compatible IoC*/
	public Pot(Plante plante) {
		this.plante = plante;
	}
}

Plante a ici la responsabilité de l'instanciation de la Tomate.
Mais si l'application évolue, qu'on souhaite l'étendre, ou qu'on souhaite mocker cette instanciation (exemple si c'est un web service) on doit modifier le code.

On veut pouvoir mocker / étendre / sans modifier le code et donc externaliser la responsabilité des instanciations.


 --- Exemple de base :

Exemple springFormation_1 : en XML
Dépendance de context : https://mvnrepository.com/artifact/org.springframework/spring-context/4.3.2.RELEASE
app / beans / core / expression

Il est possible d'avoir plusieurs fichiers XML mais un seul d'entrée. C'est l'applicationContext qui va importer les autres fichiers.

Exemple springFormation_2 : en full annotation

Les annotations sont pas toujours préférables à l'xml. On peut faire plus de chose en XML. Par exemple déclaré des beans différents sur une même classe (impossible en annotation).
Il n'y a pas de choix à faire, le mix est l'alliage parfait et dépend du projet.

Note sur springFormation_2 : On peut rtrouver l'annotation @Bean aussi

Ainsi, si dans messageServiceImpl on supprime le @Component, on peut déclarer dans la classe Application :
    @Bean
    public MessageServiceImpl messageService(){
        return new MessageServiceImpl();
    }

Il est à noter que l'on peut avoir plusieurs @Configuration si on souhaite découper notre application.
On peut réaliser des héritages / dépendances avec @Import(nomClass.class)


 --- Component

Déclaration du component "Peugeot" va créé un bean nommé automatiquement "peugeot". Il est possible de définir explicitement ce nom.
Il y a des dérivés à @component => @Repository @Service @Controller
C'est la même chose mais permet de réaliser de l'AOP plus efficacement et certains outils recherche les bonnes annotations.


 --- Autowire / Resource

Les deux fonctionne par recherche type. Mais autowire peut spécifier qu'il n'est pas obligatoire et resource permet de spécifier un nom de bean explicite.

Autowire : Attention, définir 2 beans sur la même classe = autowired plante parcequ'il ne sait pas lequel prendre
 => démontrer.
    1. Créer une classe MessageServiceAutreImpl qui implémente MessageService
    2. Lancer l'appli. => plante.

Et au final : setter ou constructeur pour déclarer les dépendances ?
On peut mixer les deux. La logique veut qu'on mette en setter les dépendances facultatives et en constructeurs les obligatoires.


 --- scope

Faire un test sur formationSpring_2 en ajoutant un 2ème service dans MessagePrinter.
Puis ajouter dans l'appel d'affichage
        System.out.println(service2.getMessage());
        service2.setMessage("message modifié");
        System.out.println(service.getMessage());
        System.out.println(service2.getMessage());

Par défaut tout est singleton ! => @Scope("prototype")


 --- Injecter une collection (list / set / map / props)

Exemple avec le projet spring 3.
Remarque : tout est String dans un fichier xml ... mais spring sait faire une conversion Integer par exemple (dans la map).
L'utilité de tout ça ? notamment pour injecter des listes de beans / référence.

Remarque : comment injecter null ? "" représentant une chaîne vide ? Il y a un tag pour ça <value><null/></value>


 --- init-method

Par défaut on appel le constructeur sans paramètre. On peut vouloir initialiser un appel :  <bean id="..." class="..." init-method="...">
Modifier l'un des projets pour ajouter une init method à messageServiceImpl qui changerait le message par exemple.


 --- appeler un new

Essayons de faire un new plutôt que d'instancier via spring
    => l'objet est hors contexte, pas d'initialisation de variable etc. Erreur courante au début !


 --- Héritage de bean + parent (http://www.tutorialspoint.com/spring/spring_bean_definition_inheritance.htm)

Il est possible de réaliser de l'héritage entre bean, mais ça n'a pas le même sens que pour Java.
Ce n'est que de l'héritage au niveau de la configuration des beans.
    <bean id="helloWorld" class="com.tutorialspoint.HelloWorld"> // peut le rendre abstract="true" sans définir de class
       <property name="message1" value="Hello World!"/>
       <property name="message2" value="Hello Second World!"/>
    </bean>

    <bean id="helloIndia" class="com.tutorialspoint.HelloIndia" parent="helloWorld">
       <property name="message1" value="Hello India!"/>
       <property name="message3" value="Namaste India!"/>
    </bean>


=> Exercice Final : Création d'un concessionnaire ? (basé sur l'exemple des plantes).
    Concessionnaire qui possède deux parcelles (parking interne et parking extérieur)
    Chaque parking accueille des vehicules d'un certain noms (zoé / mégane)


### 2. Spring properties

    Exemple du projet 4.

    On peut récupérer les valeurs directement dans l'initialisation d'un bean ou via un @Value.

    Pour utiliser la variable, déclarer dans les arguments VM : -Dproject.home=c:/
    Rajouter une valeur par défaut : :c:/conf/


###  3. Spring MVC

 3.1 Rappel MVC

    Découpage de responsabilité ...
    C'est comme struts.

 3.2 Pattern dispatcher de base (servlet web.xml @controler / model / resolver)

    Spring MVC est une spécialisation de Spring qui donne des outils pour gérer des pages web.
    Tout tourne autour du servletDispatcher (remplace notre main)

    prendre l'image de http://www.tutorialspoint.com/spring/spring_web_mvc_framework.htm sur les étapes
    ainsi que les explications

    spring-web => étend le core
    spring-webmvc => ajoute la couche mvc

    Prendre exemple du projet spring 5 : localhost:8080/hello
        Lancer l'appli et accéder à http://localhost:8080/hello (si lancer depuis intellIJ)
        web.xml => dispatcher servlet
        HelloController => @Controller @RequestMapping
        hello-servlet
            => Spring recherche automatiquement le fichier {{nomServlet}}-servlet.xml
            => On peut lui préciser d'autres noms dans le web.xml
            => Contient la ligne de scan pour les controller
            => Contient un résolver permettant de rediriger vers nos ressources JSP.
                => Le resolver peut implémenter des framework de view comme Tiles / Velocity / ...

 3.3 Spring el

    Prendre exemple du projet spring 6 : localhost:8080/hello & localhost:8080/hello/toto
        dépendance : ne pas oublier d'ajouter javax.servlet
        spring-el est déjà en dépendance de webmvc

    -- Piège :

    Attention à la vieille erreur que les paramètres ne s'affichent pas sur les JSP
        https://www.mkyong.com/spring-mvc/modelandviews-model-value-is-not-displayed-in-jsp-via-el/
    (web.xml) EL ne marche pas :
       <!DOCTYPE web-app PUBLIC
            "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN"
            "http://java.sun.com/dtd/web-app_2_3.dtd" >
    (web.xml) EL marche :
        <web-app id="WebApp_ID" version="2.4"
            xmlns="http://java.sun.com/xml/ns/j2ee"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xsi:schemaLocation="http://java.sun.com/xml/ns/j2ee
            http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd">

 3.4 Spring resource static

    Spring défini un context de ressource static (pour ne pas être pris en compte par le resolver notamment.
    Prendre l'exemple de spring 6. Ajout dans le servlet.xml de
        <mvc:resources mapping="/resources/**" location="/resources/"/>
        <mvc:annotation-driven/>
    Dans hello.jsp ajout des références et utilisation de taglib.

 3.5 Redirect et forward

    Exemple du projet 7 : localhost:8080/index
    => Sur le redirect, on retourne directement sur le navigateur avec une réponse http 302 qui provoque une redirection vers la nouvelle URL. => on perd la request !
    => Pour ne pas perdre la request : forward
    => On montre que les signatures sont dynamiques, liste des variables possibles :
        http://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html#mvc-ann-arguments

 3.6 Gérer un formulaire

    Exemple du projet FormationSpring_8 :
    Pour gérer un formulaire on a un objet "command" qui attend un bean (attention aux setter / getter)
    Mais il est possible de paramétrer le nom du bean attaché au formulaire via l'attribut modelAttribute.
    Lors du submit, on récupère tout simplement cet objet en signature de méthode

 3.7 Spring message & internationalisation

    Exemple du projet FormationSpring_9 :

    ordre de priorité :
        application_fr_FR
        application_fr
        application

    On a ajouté un resolver ainsi qu'un interceptor, via l'url on peut changer la locale.
        http://localhost:8080/student
        http://localhost:8080/student?locale=en
    De manière native c'est géré par le accept language de la requête HTTP.

    Pour gérer des fichiers externe à l'application ?
        <value>file:/usr/local/conf/app/messages/messages</value>

    Pour récupérer les messages : spring:message
    Dans un controller injecter le bean.


 3.8 Gérer un formulaire avec validation

    Avant la version 4 et après la 3 => Librairie externe : JSR-303/JSR-349 Bean Validation notamment avec
        <dependency>
            <groupId>javax.validation</groupId>
            <artifactId>validation-api</artifactId>
            <version>1.0.0.GA</version>
        </dependency>
        <dependency>
            <groupId>org.hibernate</groupId>
            <artifactId>hibernate-validator</artifactId>
            <version>4.1.0.Final</version>
        </dependency>
    exemple dans ce lien : http://blog.netapsys.fr/spring-mvc-formulaires-et-validations-par-la-norme-jsr-303-bean-validation/

    Après la version 4 => Spring intégre cette norme à sa sauce @Validated (http://www.mkyong.com/spring-mvc/spring-mvc-form-handling-example/)
    Exemple du projet FormationSpring_10 :

    C'est le même projet que 8 avec les étudiants mais avec une validation.
        On rajoute l'email pour montrer les dépendances de validator.
        Ajout de deux validator
        Ajout du tag form:error dans la jsp du formulaire
        Modification du controller pour déclencher le validator
        Détail sur le messageRessource => On a plusieurs fichiers de messageResource maintenant.
            Note : il y a un ordre d'application. Le dernier prend le pas sur les suivant.
            Permet de faire du fallback. On charge d'abord le fichier dans l'appli puis un externe par exemple.

    Attention ! Dans le controller, l'attribut BindingResult result doit obligatoirement être placé juste après le modelAttribute à valider.
    Sinon erreur 400 ! C'est le seul paramètre qui a une place conditionné au niveau des controlleurs spring.
    => http://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html#mvc-ann-methods


 3.8 UTF-8 encoding

    Petit détail dans le projet 10, l'encoding filter a été ajouté dans le web.xml
    Permet de filtrer toutes les transactions HTTP pour notamment récupérer les données formulaires en UTF-8


4. spring test + JUnit

5. Spring security

6. Spring batch

7. Les bonus
 7.1 AOP

    -- BeanPostProcessor

    Spring recherche automatiquement toutes les classes héritant de BeanPostProcessor
    @Component
    public class InitHelloWorld implements BeanPostProcessor {
       public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
          System.out.println("BeforeInitialization : " + beanName);
          return bean;  // you can return any other object as well
       }
       public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
          System.out.println("AfterInitialization : " + beanName);
          return bean;  // you can return any other object as well
       }
    }

    Bien appeler context.registerShutdownHook(); dans le main pour pouvoir lancer correctement les destroy.
        (A combiner avec les init méthod et destroy method)


    -- AspectJ

    <!-- ANNOTATIONS POUR AOP -->
	<aop:aspectj-autoproxy />

    http://www.tutorialspoint.com/spring/aop_with_spring.htm


 7.2 spring boot


 7.3 Topo sur les autres modules

    On peut gérer
        - du cache (ehcache)
        - du cron / quartz
        - du jdbc / jpa
        - mail
        - jms
        - Rest
        - ...


### 8. Petit quiz pour réaliser un résumé / rappel

    http://www.tutorialspoint.com/spring/spring_mock_test.htm




### 9. Lien divers :

 La bible : http://www.mkyong.com/
 www.spring.io
 http://www.tutorialspoint.com/spring/
 http://yannart.developpez.com/java/spring/tutoriel/
